namespace CauchyMethods
{

    //Класс, содержащий условия задачи Коши
    public class CauchyConditions
    {
        //Поле, содержащее значение количества итераций
        private int n;

        //Поле, содержащее значение левой границы отрезка области решений
        private double a;

        //Поле, содержащее значение правой границы отрезка области решений
        private double b;

        //Поле, содержащее значение y в точке x0
        private double y1;

        //Свойство для поля количества итераций
        public int Iterations
        {
            get
            {
                return n;
            }

            set
            {
                n = value;
            }
        }

        //Свойство для поля левой границы отрезка области решений
        public double A
        {
            get
            {
                return a;
            }

            set
            {
                a = value;
            }
        }

        //Свойство для поля правой границы отрезка области решений
        public double B
        {
            get
            {
                return b;
            }

            set
            {
                b = value;
            }
        }

        //Свойство для поля значения y в точке x0
        public double Y
        {
            get
            {
                return y1;
            }

            set
            {
                y1 = value;
            }
        }

        //Конструктор с условиями - вводятся обе границы области решений, значение y в точке x0, количество итераций
        public CauchyConditions(double a, double b, double y, int n)
        {
            Iterations = n;
            A = a;
            B = b;
            Y = y;
        }
    }

    //Класс с функциями производных
    public class Derivative
    {
        //Функция для вычисления значения функции производной x^2 + y
        public static double SimpleSquare(double x, double y)
        {
            return y + x * x;
        }

        //Функция для вычисления значения функции производной (x - y)^2 + 1
        public static double Square(double x, double y)
        {
            return 1.0 + (x - y) * (x - y);
        }
    }

    //Класс, содержащий методы решения задачи Коши
    public class Methods
    {
        //Делегат, необходимый для передачи в функцию метода функцию вида f(x,y), возвращающую число с плавающей запятой
        public delegate double function(double x, double y);

        //Функция, решающая задачу Коши методом Эйлера, принимает в качестве аргумента экземпляр класса CauchyConditions,
        //содержащий условия задачи, и функцию, соответствующую делегату function, возвращает двумерный массив чисел с плавающей запятой
        static public double[,] Euler(CauchyConditions cauCon, function func)
        {
            //Расчёт шага вычислением разницы между границами отрезка и делением её на количество итераций
            double h = (cauCon.B - cauCon.A) / cauCon.Iterations;
            //Инициализация двумерного массива с двумя строками, в первой строке которого будут содержаться значения x,
            //а во второй - значения y
            double[,] solution = new double[2, cauCon.Iterations];
            for (int i = 0; i < cauCon.Iterations; i++)
            {
                solution[1, i] = cauCon.Y;
                //Вычисление значения переданной функции с текущими x и y
                double f1 = func(cauCon.A, cauCon.Y);
                //Вычисление значения y по формуле y = y(текущий) + f(x(текущий), y(текущий)) * h(шаг)
                cauCon.Y += f1 * h;
                //Запись полученных значений в двумерный массив 
                solution[0, i] = cauCon.A;
                //Расчёт следующего x прибавлением значения шага
                cauCon.A += h;
            }
            return solution;
        }

        //Функция, решающая задачу Коши модифицированным методом Эйлера, принимает в качестве аргумента экземпляр класса CauchyConditions,
        //содержащий условия задачи, и функцию, соответствующую делегату function, возвращает двумерный массив чисел с плавающей запятой
        static public double[,] ModifiedEuler(CauchyConditions cauCon, function func)
        {
            //Расчёт шага вычислением разницы между границами отрезка и делением её на количество итераций
            double h = (cauCon.B - cauCon.A) / cauCon.Iterations;
            //Инициализация двумерного массива с двумя строками, в первой строке которого будут содержаться значения x,
            //а во второй - значения y
            double[,] solution = new double[2, cauCon.Iterations];
            //Инициализация переменной для значения функции, рассчитанной для текущих значений x и y,
            //переменной для значения функции, рассчитанной для новых значений x и y, и переменной,
            //в которую записывается предыдущее значение y, соответственно
            double f1, f2, y0;
            for (int i = 0; i < cauCon.Iterations; i++)
            {
                //Запись предыдущего значения y
                y0 = cauCon.Y;
                //Запись полученного значения x в двумерный массив
                solution[0, i] = cauCon.A;
                solution[1, i] = cauCon.Y;
                //Вычисление значения переданной функции с текущими x и y
                f1 = func(cauCon.A, cauCon.Y);
                //Расчёт следующего x прибавлением значения шага
                cauCon.A += h;
                //Вычисление нового значения y по формуле y = y(текущий) + f(x(текущий), y(текущий)) * h(шаг)
                cauCon.Y += h * f1;
                //Вычисление значения переданной функции с новыми x и y
                f2 = func(cauCon.A, cauCon.Y);
                //Пересчёт значения y по формуле
                //y = y(предыдущий) + h(шаг) / 2 * (f(x(текущий), y(текущий)) + f(x(новый), y(новый)))
                cauCon.Y = y0 + h / 2.0 * (f1 + f2);
                //Запись полученного значения y в двумерный массив
                
            }
            return solution;
        }

        static public double[,] RungeKutta(CauchyConditions cauCon, function func)
        {
            //Инициализация двумерного массива с двумя строками, в первой строке которого будут содержаться значения x,
            //а во второй - значения y
            double[,] solution = new double[2, cauCon.Iterations];
            //Расчёт шага вычислением разницы между границами отрезка и делением её на количество итераций
            double h = (cauCon.B - cauCon.A) / cauCon.Iterations;
            //Инициализация переменной для значения предыдущего x, переменной для значения предыдущего y,
            //переменных для пересчёта функции в 4 шага соответственно
            double x0, y0, k1, k2, k3, k4;

            for (int i = 0; i < cauCon.Iterations; i++)
            {
                //Запись полученного значения x в двумерный массив
                solution[0, i] = cauCon.A;
                solution[1, i] = cauCon.Y;
                //Запись предыдущих значений x и y
                x0 = cauCon.A;
                y0 = cauCon.Y;
                //Первый шаг: рассчёт переданной функции для предыдущих x и y
                k1 = func(cauCon.A, cauCon.Y);

                //Пересчёт значения x для второго шага по формуле x = x(предыдущий) + h(шаг) / 2
                cauCon.A = x0 + h / 2.0;
                //Пересчёт значения y для второго шага по формуле y = y(предыдущий) + h(шаг) / 2 * k1(первый шаг)
                cauCon.Y = y0 + h / 2.0 * k1;
                //Второй шаг: расчёт переданной функции для пересчитанных x и y
                k2 = func(cauCon.A, cauCon.Y);

                //Пересчёт значения y для третьего шага по формуле y = y(предыдущий) + h(шаг) / 2 * k2(второй шаг)
                cauCon.Y = y0 + h / 2.0 * k2;
                //Третий шаг: расчёт переданной функции для x и пересчитанного ещё раз y
                k3 = func(cauCon.A, cauCon.Y);

                //Пересчёт значения x для четвёртого шага по формуле x = x(предыдущий) + h(шаг)
                cauCon.A = x0 + h;
                //Пересчёт значения y для второго шага по формуле y = y(предыдущий) + h(шаг) * k3(третий шаг)
                cauCon.Y = y0 + h * k3;
                //Четвёртый шаг: расчёт переданной функции для пересчитанных ещё раз x и y
                k4 = func(cauCon.A, cauCon.Y);

                //Вычисление нового значения y по формуле
                //y = y(предыдущий) + h(шаг) / 6 * (k1(первый шаг) + 2 * k2(второй шаг) + 2 * k3(третий шаг) + k4(четвёртый шаг))
                cauCon.Y = y0 + h / 6.0 * (k1 + 2 * k2 + 2 * k3 + k4);

                //Запись нового значения y в двумерный массив
            }
            return solution;
        }
    }
}
